// Ensure Lottie Player is loaded (already in <head>)
const CDN_BASE_URL = "https://cdn.changes.tg/gifts/";
const GIFTS_JSON_URL = `${CDN_BASE_URL}id-to-name.json`;

const PIN_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>pin</title><path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z" /></svg>`;
const BACK_ARROW_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>arrow-left-bold</title><path d="M20,9V15H12V19.84L4.16,12L12,4.16V9H20Z" /></svg>`;
const DIAMOND_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>diamond-stone</title><path d="M16,9H19L14,16M10,9H14L12,17M5,9H8L10,16M15,4H17L19,7H16M11,4H13L14,7H10M7,4H9L8,7H5M6,2L2,8L12,22L22,8L18,2H6Z" /></svg>`;
const CROWN_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>crown</title><path d="M5 16L3 5L8.5 10L12 4L15.5 10L21 5L19 16H5M19 19C19 19.6 18.6 20 18 20H6C5.4 20 5 19.6 5 19V18H19V19Z" /></svg>`;
const LABEL_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>label</title><path d="M17.63,5.84C17.27,5.33 16.67,5 16,5H5A2,2 0 0,0 3,7V17A2,2 0 0,0 5,19H16C16.67,19 17.27,18.66 17.63,18.15L22,12L17.63,5.84Z" /></svg>`;
const TRASH_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>trash-can-outline</title><path d="M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M7,6H17V19H7V6M9,8V17H11V8H9M13,8V17H15V8H13Z" /></svg>`;

let allAvailableGifts = {};
let ownedGifts = [];
let pinnedGifts = [];
let wornGiftInstanceId = null;
const MAX_PINS = 6;
let tg = window.Telegram.WebApp;

let activeFilters = { collection: null, model: null, backdrop: null, pattern: null };

const profilePage = document.getElementById('profile-page');
const profileBackButton = document.getElementById('profile-back-button');
const profileTopSection = document.getElementById('profile-top-section');
const profileHeaderPatternOverlay = document.getElementById('profile-header-pattern-overlay');
const profileAvatar = document.getElementById('profile-avatar');
const profileName = document.getElementById('profile-name');
const wornGiftIconContainer = document.getElementById('worn-gift-icon-container'); // Changed from img
const profileGiftCountSubtext = document.getElementById('profile-gift-count-subtext');
const profileStatus = document.getElementById('profile-status');
const profilePhone = document.getElementById('profile-phone');
const profileBio = document.getElementById('profile-bio');
const profileUsername = document.getElementById('profile-username');
const profileTopPinnedGifts = document.getElementById('profile-top-pinned-gifts');
const giftsGrid = document.getElementById('gifts-grid');
const goToBuyGiftsButton = document.getElementById('go-to-buy-gifts');
const upgradeAllGiftsButton = document.getElementById('upgrade-all-gifts-button');
const filterLongPressTarget = document.getElementById('filter-long-press-target');

const buyGiftsPage = document.getElementById('buy-gifts-page');
const backToProfileBuyButton = document.getElementById('back-to-profile-buy');
const buyGiftsGrid = document.getElementById('buy-gifts-grid');

const giftDetailModal = document.getElementById('gift-detail-modal');
const modalGiftName = document.getElementById('modal-gift-name');
const modalLottieGiftOriginal = document.getElementById('modal-lottie-gift-original');
const modalGiftImageStatic = document.getElementById('modal-gift-image-static');
const modalGiftDescription1 = document.getElementById('modal-gift-description1');
const modalGiftDescription2 = document.getElementById('modal-gift-description2');
const modalGiftInfo = document.getElementById('modal-gift-info');
const closeGiftDetailModalButton = document.getElementById('close-gift-detail-modal');

const collectibleDetailModal = document.getElementById('collectible-detail-modal');
const backFromCollectibleModal = document.getElementById('back-from-collectible-modal');
const modalCollectibleHeaderTitle = document.getElementById('modal-collectible-header-title');
const modalCollectibleVisual = document.getElementById('modal-collectible-visual');
const modalCollectibleBg = document.getElementById('modal-collectible-bg');
const modalCollectiblePattern = document.getElementById('modal-collectible-pattern');
const modalLottieCollectibleModel = document.getElementById('modal-lottie-collectible-model');
const modalCollectibleModelImgStatic = document.getElementById('modal-collectible-model-img-static');
const modalCollectibleMainName = document.getElementById('modal-collectible-main-name');
const modalCollectibleNumberSubtext = document.getElementById('modal-collectible-number-subtext');
const modalCollectibleInfoTable = document.getElementById('modal-collectible-info-table');
const collectibleActionTransfer = document.getElementById('collectible-action-transfer');
const collectibleActionWear = document.getElementById('collectible-action-wear');
const collectibleActionSell = document.getElementById('collectible-action-sell');
const closeCollectibleDetailModalButton = document.getElementById('close-collectible-detail-modal');

const tooManyPinsModal = document.getElementById('too-many-pins-modal');
const unpinSelectionGrid = document.getElementById('unpin-selection-grid');
const cancelUnpinModal = document.getElementById('cancel-unpin-modal');
const buyMultipleModal = document.getElementById('buy-multiple-modal');
const buyMultipleModalTitle = document.getElementById('buy-multiple-modal-title');
const buyMultipleGiftName = document.getElementById('buy-multiple-gift-name');
const buyMultipleQuantityInput = document.getElementById('buy-multiple-quantity');
const confirmBuyMultipleButton = document.getElementById('confirm-buy-multiple');
const cancelBuyMultipleButton = document.getElementById('cancel-buy-multiple');
let currentGiftToBuyMultiple = null;
const longPressMenu = document.getElementById('long-press-menu');
const menuPinAction = document.getElementById('menu-pin-action');
const giftsLoadingSpinner = document.getElementById('gifts-loading-spinner');
const buyGiftsLoadingSpinner = document.getElementById('buy-gifts-loading-spinner');
const filterPopup = document.getElementById('filter-popup');
const filterModelsSection = document.getElementById('filter-models-section');
const filterOptionsCollections = document.getElementById('filter-options-collections');
const filterOptionsModels = document.getElementById('filter-options-models');
const filterOptionsBackdrops = document.getElementById('filter-options-backdrops');
const filterOptionsPatterns = document.getElementById('filter-options-patterns');
const applyFiltersButton = document.getElementById('apply-filters-button');
const clearFiltersButton = document.getElementById('clear-filters-button');
const clearAllDataButton = document.getElementById('clear-all-data-button');
const clearDataIconPlaceholder = document.getElementById('clear-data-icon-placeholder');

const russianFirstNames = ["Василий", "Иван", "Алексей", "Дмитрий", "Сергей"];
const russianLastNames = ["Дуров", "Петров", "Иванов", "Смирнов", "Кузнецов"];
const russianBios = ["Всё только начинается.", "Люблю путешествовать.", "Кофеман."];

function getRandomElement(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function generateRandomPhoneNumber() {
    let num = '+7 (9'; for (let i = 0; i < 2; i++) num += Math.floor(Math.random() * 10); num += ') ';
    for (let i = 0; i < 3; i++) num += Math.floor(Math.random() * 10); num += '-';
    for (let i = 0; i < 2; i++) num += Math.floor(Math.random() * 10); num += '-';
    for (let i = 0; i < 2; i++) num += Math.floor(Math.random() * 10); return num;
}
function generateUniqueId() { return `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 9)}`; }
const mockUser = {
    first_name: getRandomElement(russianFirstNames), last_name: getRandomElement(russianLastNames),
    photo_url: `https://i.pravatar.cc/140?u=${generateUniqueId()}`, bio: getRandomElement(russianBios), phone: generateRandomPhoneNumber()
};
mockUser.username = `${mockUser.first_name.toLowerCase().replace(' ', '')}${Math.floor(Math.random() * 1000)}`;

let lottieIntersectionObserver;

function playLottieAnimation(container, path, loop = true, isGridItem = false) {
    if (!container || !path) return;
    if (container.lottieInstance) { container.lottieInstance.destroy(); delete container.lottieInstance; }
    container.innerHTML = '';
    const anim = bodymovin.loadAnimation({
        container: container, path: path, renderer: 'svg', loop: loop, autoplay: true
    });
    container.lottieInstance = anim;
    if (isGridItem && !loop) {
        anim.addEventListener('complete', () => {
            if (container.lottieInstance === anim) { // Ensure it's the current animation
                container.dataset.playedOnce = 'true';
            }
        });
    }
}
function destroyLottieAnimation(container) {
    if (container && container.lottieInstance) {
        container.lottieInstance.destroy();
        delete container.lottieInstance;
        delete container.dataset.playedOnce; // Reset for re-play on re-view
        container.innerHTML = ''; // Clear container
    }
}

function handleLottieIntersection(entries, observer) {
    entries.forEach(entry => {
        const cardElement = entry.target;
        const lottieContainer = cardElement.querySelector('.lottie-animation-container');
        const staticFallback = cardElement.querySelector('.static-image-fallback');
        const lottiePath = cardElement.dataset.lottiePath;

        if (entry.isIntersecting) {
            if (lottiePath && lottieContainer) {
                if(staticFallback) staticFallback.style.display = 'none';
                lottieContainer.style.display = 'flex'; // Make sure it's visible
                // Play once, then stop. Replay if it scrolls out and back in.
                playLottieAnimation(lottieContainer, lottiePath, false, true);
            }
        } else {
            if (lottieContainer) {
                destroyLottieAnimation(lottieContainer);
                if(staticFallback) staticFallback.style.display = 'block'; // Show fallback
                lottieContainer.style.display = 'none';
            }
        }
    });
}

function initLottieObserver() {
    lottieIntersectionObserver = new IntersectionObserver(handleLottieIntersection, {
        root: null, // viewport
        rootMargin: '100px', // Load/unload when 100px from viewport edge
        threshold: 0.01 // Trigger even if 1% is visible
    });
}

function observeLottieElement(element) {
    if (lottieIntersectionObserver && element.dataset.lottiePath) {
        lottieIntersectionObserver.observe(element);
    }
}
function unobserveLottieElement(element) {
     if (lottieIntersectionObserver && element.dataset.lottiePath) { // Check if it was observed
        lottieIntersectionObserver.unobserve(element);
        const lottieContainer = element.querySelector('.lottie-animation-container');
        if(lottieContainer) destroyLottieAnimation(lottieContainer); // Clean up immediately
    }
}


function initApp() {
    tg.ready(); tg.expand();
    applyTheme(tg.themeParams);
    tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
    initLottieObserver();

    profileBackButton.innerHTML = BACK_ARROW_SVG;
    backToProfileBuyButton.innerHTML = BACK_ARROW_SVG;
    backFromCollectibleModal.innerHTML = BACK_ARROW_SVG;
    collectibleActionTransfer.querySelector('.icon').innerHTML = DIAMOND_SVG;
    collectibleActionWear.querySelector('.icon').innerHTML = CROWN_SVG;
    collectibleActionSell.querySelector('.icon').innerHTML = LABEL_SVG;
    clearDataIconPlaceholder.innerHTML = TRASH_ICON_SVG;

    loadUserData(); loadState();
    applyWornGiftStyles(wornGiftInstanceId);
    renderProfileGifts();
    setupEventListeners();
    fetchAvailableGifts();
}

function applyTheme(themeParams) { /* Same as before */ 
    if (themeParams && Object.keys(themeParams).length > 0) {
        const root = document.documentElement;
        const setVar = (varName, value) => { if (value) root.style.setProperty(varName, value); };
        setVar('--tg-theme-bg-color', themeParams.bg_color);
        setVar('--tg-theme-text-color', themeParams.text_color);
        setVar('--tg-theme-hint-color', themeParams.hint_color);
        setVar('--tg-theme-link-color', themeParams.link_color);
        setVar('--tg-theme-button-color', themeParams.button_color);
        setVar('--tg-theme-button-text-color', themeParams.button_text_color);
        setVar('--tg-theme-secondary-bg-color', themeParams.secondary_bg_color);
        setVar('--tg-theme-accent-blue', themeParams.accent_text_color || '#5288c1');
        document.body.style.backgroundColor = themeParams.bg_color || 'var(--tg-theme-bg-color)';
        document.body.style.color = themeParams.text_color || 'var(--tg-theme-text-color)';
        if (upgradeAllGiftsButton) upgradeAllGiftsButton.style.backgroundColor = themeParams.accent_text_color || 'var(--tg-theme-accent-blue)';
        applyWornGiftStyles(wornGiftInstanceId);
    } else console.log("Using default CSS variables as themeParams are empty.");
}
function loadUserData() { /* Same as before */ 
    const user = tg.initDataUnsafe?.user || mockUser;
    profileName.textContent = user.first_name || mockUser.first_name;
    profileAvatar.src = user.photo_url || mockUser.photo_url;
    profileAvatar.onerror = () => { profileAvatar.src = `https://i.pravatar.cc/140?u=fallback${generateUniqueId()}`; };
    profileUsername.textContent = user.username ? `@${user.username}` : `@${mockUser.username}`;
    profileBio.textContent = user.bio || mockUser.bio;
    profilePhone.textContent = user.phone || mockUser.phone;
}
function saveState() { /* Same as before */ 
    localStorage.setItem('ownedGifts_v7', JSON.stringify(ownedGifts));
    localStorage.setItem('pinnedGifts_v7', JSON.stringify(pinnedGifts));
    localStorage.setItem('wornGiftInstanceId_v7', wornGiftInstanceId);
    localStorage.setItem('activeFilters_v7', JSON.stringify(activeFilters));
}
function loadState() { /* Same as before */ 
    const loadedOwnedGifts = JSON.parse(localStorage.getItem('ownedGifts_v7')) || [];
    ownedGifts = loadedOwnedGifts.map(gift => ({ ...gift, instanceId: gift.instanceId || generateUniqueId() }));
    pinnedGifts = JSON.parse(localStorage.getItem('pinnedGifts_v7')) || [];
    wornGiftInstanceId = localStorage.getItem('wornGiftInstanceId_v7') || null;
    activeFilters = JSON.parse(localStorage.getItem('activeFilters_v7')) || { collection: null, model: null, backdrop: null, pattern: null };
}

function applyWornGiftStyles(instanceId) {
    const currentWornGift = ownedGifts.find(g => g.instanceId === instanceId && g.isCollectible);
    destroyLottieAnimation(wornGiftIconContainer); // Clear previous if any
    if (currentWornGift && currentWornGift.collectibleData) {
        if (currentWornGift.collectibleData.lottieModelPath) {
            playLottieAnimation(wornGiftIconContainer, currentWornGift.collectibleData.lottieModelPath, true);
        } else if (currentWornGift.collectibleData.modelImage) { // Fallback to static if no Lottie
            wornGiftIconContainer.innerHTML = `<img src="${currentWornGift.collectibleData.modelImage}" style="width:100%; height:100%; object-fit:contain;">`;
        }
        wornGiftIconContainer.classList.remove('hidden');
        const colors = currentWornGift.collectibleData.backdropColors;
        if (colors) profileTopSection.style.background = `radial-gradient(circle at 50% 0%, ${colors.centerColor} 0%, ${colors.edgeColor} 100%)`;
        else profileTopSection.style.background = 'var(--app-profile-gradient-fallback)';
        if (currentWornGift.collectibleData.patternImage) {
            profileHeaderPatternOverlay.style.backgroundImage = `url('${currentWornGift.collectibleData.patternImage}')`;
            profileHeaderPatternOverlay.style.opacity = '0.07';
        } else profileHeaderPatternOverlay.style.backgroundImage = 'none';
    } else {
        wornGiftIconContainer.classList.add('hidden');
        wornGiftIconContainer.innerHTML = '';
        profileTopSection.style.background = 'var(--app-profile-gradient-fallback)';
        profileHeaderPatternOverlay.style.backgroundImage = 'none';
    }
}

function showPage(pageId) { /* Same as before */ 
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(pageId).classList.add('active');
}
async function fetchAvailableGifts() { /* Same as before, ensure populateFilterOptions is called */ 
    buyGiftsLoadingSpinner.classList.remove('hidden');
    buyGiftsGrid.innerHTML = '';
    try {
        const response = await fetch(GIFTS_JSON_URL);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        allAvailableGifts = await response.json();
        renderAvailableGifts(); // This will now set up Lottie observation for buy grid
        populateFilterOptions();
    } catch (error) {
        console.error("Не удалось загрузить доступные подарки:", error);
        buyGiftsGrid.innerHTML = `<p class="empty-grid-message" style="width:100%;">Не удалось загрузить подарки. Попробуйте позже.</p>`;
    } finally {
        buyGiftsLoadingSpinner.classList.add('hidden');
    }
}

function renderAvailableGifts() { // Modified for Lottie
    buyGiftsGrid.innerHTML = '';
    if (Object.keys(allAvailableGifts).length === 0 && !buyGiftsLoadingSpinner.classList.contains('hidden')) {
        buyGiftsGrid.innerHTML = `<p class="empty-grid-message" style="width:100%;">Сейчас нет доступных подарков.</p>`; return;
    }
    for (const id in allAvailableGifts) {
        const name = allAvailableGifts[id];
        const originalImageUrl = `${CDN_BASE_URL}originals/${id}/Original.png`;
        const lottiePath = `${CDN_BASE_URL}originals/${id}/Original.json`;

        const item = document.createElement('div');
        item.className = 'buy-gift-item';
        item.dataset.id = id; item.dataset.name = name;
        item.dataset.originalImage = originalImageUrl;
        item.dataset.lottiePath = lottiePath; // For IntersectionObserver

        item.innerHTML = `
            <div class="image-container">
                <div class="lottie-animation-container" style="display:none;"></div>
                <img class="static-image-fallback" src="${originalImageUrl}" alt="${name}" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.innerHTML = '🖼️';">
            </div>
            <div class="gift-name">${name}</div>
            <div class="gift-price"><span class="star-icon">⭐</span> Бесплатно</div>
            <div class="limited-label">Ограничено</div>
        `;
        item.addEventListener('click', () => buyGift(id, name, originalImageUrl, lottiePath, 1)); // Pass Lottie path
        let buyItemLongPressTimer;
        item.addEventListener('touchstart', (e) => { buyItemLongPressTimer = setTimeout(() => openBuyMultipleModal(id, name, originalImageUrl, lottiePath), 700); }, { passive: true });
        item.addEventListener('touchend', () => clearTimeout(buyItemLongPressTimer));
        item.addEventListener('touchmove', () => clearTimeout(buyItemLongPressTimer));
        item.addEventListener('contextmenu', (e) => { e.preventDefault(); openBuyMultipleModal(id, name, originalImageUrl, lottiePath); });
        
        observeLottieElement(item); // Observe for intersection-based animation
        buyGiftsGrid.appendChild(item);
    }
}

function getGiftCountText(count) { /* Same as before */ 
    if (count % 10 === 1 && count % 100 !== 11) return `${count} подарок`;
    if (count % 10 >= 2 && count % 10 <= 4 && (count % 100 < 10 || count % 100 >= 20)) return `${count} подарка`;
    return `${count} подарков`;
}
function renderProfileGifts() { /* Modified to unobserve old elements */ 
    // Unobserve old elements before clearing
    Array.from(giftsGrid.children).forEach(child => unobserveLottieElement(child));
    giftsGrid.innerHTML = '';
    
    const filteredGifts = ownedGifts.filter(gift => { /* ... filter logic same ... */ 
        if (activeFilters.collection && gift.id !== activeFilters.collection) return false;
        if (gift.isCollectible && gift.collectibleData) {
            if (activeFilters.model && gift.collectibleData.model?.name !== activeFilters.model) return false;
            if (activeFilters.backdrop && gift.collectibleData.backdrop?.name !== activeFilters.backdrop) return false;
            if (activeFilters.pattern && gift.collectibleData.pattern?.name !== activeFilters.pattern) return false;
        } else if (activeFilters.model || activeFilters.backdrop || activeFilters.pattern) return false;
        return true;
    });
    profileGiftCountSubtext.textContent = getGiftCountText(filteredGifts.length);
    if (ownedGifts.length > 0 && filteredGifts.length !== ownedGifts.length) profileGiftCountSubtext.textContent += ` из ${ownedGifts.length}`;
    const sortedGifts = [...filteredGifts].sort((a, b) => { /* ... sort logic same ... */ 
        const aIsPinned = pinnedGifts.includes(a.instanceId); const bIsPinned = pinnedGifts.includes(b.instanceId);
        if (aIsPinned && !bIsPinned) return -1; if (!aIsPinned && bIsPinned) return 1;
        return (new Date(b.acquiredDate || 0)) - (new Date(a.acquiredDate || 0));
    });
    if (sortedGifts.length === 0) { /* ... empty message logic same ... */ 
        giftsGrid.style.display = 'flex'; giftsGrid.style.alignItems = 'center'; giftsGrid.style.justifyContent = 'center';
        giftsGrid.innerHTML = `<p class="empty-grid-message">${ownedGifts.length > 0 ? 'Нет подарков, соответствующих фильтрам.' : 'У вас пока нет подарков. Время что-нибудь купить!'}</p>`;
    } else {
        giftsGrid.style.display = 'grid';
        sortedGifts.forEach(gift => {
            const card = createGiftCardDOM(gift);
            giftsGrid.appendChild(card);
            observeLottieElement(card); // Observe new card
        });
    }
    renderTopPinnedGiftsPreview(); // This will also handle Lottie for pinned gifts
    const hasNonCollectible = ownedGifts.some(g => !g.isCollectible);
    if (upgradeAllGiftsButton) { /* ... button visibility logic same ... */ 
        upgradeAllGiftsButton.style.display = hasNonCollectible ? 'inline-block' : 'none';
        if (!hasNonCollectible) { upgradeAllGiftsButton.textContent = '✨ Улучшить все'; upgradeAllGiftsButton.disabled = false; }
    }
}

function createGiftCardDOM(gift) { // Modified for Lottie in grid
    const card = document.createElement('div');
    card.className = 'gift-card';
    card.dataset.instanceId = gift.instanceId;

    const imageContainer = document.createElement('div');
    imageContainer.className = 'image-container'; // Generic container class from CSS
    
    const lottieContainer = document.createElement('div');
    lottieContainer.className = 'lottie-animation-container';
    lottieContainer.style.display = 'none'; // Initially hidden, observer will show

    const staticImage = document.createElement('img');
    staticImage.className = 'static-image-fallback';
    staticImage.loading = 'lazy';

    let lottiePathForCard = null;

    if (gift.isCollectible && gift.collectibleData) {
        const cd = gift.collectibleData;
        staticImage.src = cd.modelImage || gift.originalImage;
        staticImage.alt = cd.model?.name || gift.name;
        lottiePathForCard = cd.lottieModelPath; // Use model's Lottie
        // ... (bg, pattern, badges setup - same as before) ...
        const bgDiv = document.createElement('div'); bgDiv.className = 'gift-card-bg-pattern';
        if (cd.backdropColors) bgDiv.style.background = `radial-gradient(circle, ${cd.backdropColors.centerColor}, ${cd.backdropColors.edgeColor})`;
        else bgDiv.style.background = 'linear-gradient(45deg, #2a3745, #17212b)';
        card.appendChild(bgDiv);
        if (cd.patternImage) { const pOverlay = document.createElement('div'); pOverlay.className = 'gift-card-pattern-overlay'; pOverlay.style.backgroundImage = `url('${cd.patternImage}')`; card.appendChild(pOverlay); }
        const numDiv = document.createElement('div'); numDiv.className = 'collectible-number-badge'; numDiv.textContent = `#${cd.number}`; card.appendChild(numDiv);
        if (cd.model?.rarityPermille) { const rBadge = document.createElement('div'); rBadge.className = 'gift-rarity-badge'; const tMock = Math.floor(1/(cd.model.rarityPermille/100000))*Math.max(100,cd.number/100); rBadge.textContent = `1 of ${(tMock/1000).toFixed(1)}K`; card.appendChild(rBadge); }

    } else { // Non-collectible
        staticImage.src = gift.originalImage;
        staticImage.alt = gift.name;
        lottiePathForCard = gift.lottiePath; // Use original's Lottie
    }
    
    if (lottiePathForCard) card.dataset.lottiePath = lottiePathForCard;

    staticImage.onerror = function() { this.style.display='none'; lottieContainer.innerHTML = '🖼️';}; // Simple placeholder
    
    imageContainer.appendChild(lottieContainer);
    imageContainer.appendChild(staticImage);
    card.appendChild(imageContainer);

    if (pinnedGifts.includes(gift.instanceId)) { /* ... pin indicator logic same ... */ 
        const pinDiv = document.createElement('div'); pinDiv.className = 'pin-indicator';
        pinDiv.innerHTML = PIN_ICON_SVG; pinDiv.querySelector('svg').style.fill = 'var(--tg-theme-link-color)';
        card.appendChild(pinDiv);
    }
    card.addEventListener('click', () => openGiftDetailByInstanceId(gift.instanceId));
    setupLongPress(card, gift);
    return card;
}

function createPlaceholderImage() { /* Fallback for onerror, not used directly in createGiftCardDOM anymore */ 
    const placeholder = document.createElement('div');
    placeholder.className = 'placeholder-image';
    placeholder.style.width = '100%'; placeholder.style.height = '100%';
    placeholder.textContent = '🖼️';
    return placeholder;
}

function renderTopPinnedGiftsPreview() { // Modified for Lottie
    // Destroy Lottie for old pinned gifts
    Array.from(profileTopPinnedGifts.children).forEach(childLottieContainer => {
        destroyLottieAnimation(childLottieContainer);
    });
    profileTopPinnedGifts.innerHTML = '';

    pinnedGifts.slice(0, 7).forEach(instanceId => {
        const gift = ownedGifts.find(g => g.instanceId === instanceId);
        if (gift) {
            const lottieContainer = document.createElement('div');
            lottieContainer.className = 'pinned-gift-item lottie-animation-container'; // Reused class for sizing
            
            let lottiePathForPinned = null;
            if (gift.isCollectible && gift.collectibleData?.lottieModelPath) {
                lottiePathForPinned = gift.collectibleData.lottieModelPath;
            } else if (gift.lottiePath) {
                lottiePathForPinned = gift.lottiePath;
            }

            if (lottiePathForPinned) {
                playLottieAnimation(lottieContainer, lottiePathForPinned, true); // Loop pinned gifts
            } else { // Fallback to static image if no Lottie
                lottieContainer.innerHTML = `<img src="${gift.isCollectible && gift.collectibleData?.modelImage ? gift.collectibleData.modelImage : gift.originalImage}" alt="${gift.name}" style="width:100%; height:100%; object-fit:contain;" onerror="this.parentElement.innerHTML = '🎁'">`;
            }
            profileTopPinnedGifts.appendChild(lottieContainer);
        }
    });
}

function openBuyMultipleModal(id, name, originalImage, lottiePath) { // Pass Lottie path
    currentGiftToBuyMultiple = { id, name, originalImage, lottiePath }; // Store Lottie path
    buyMultipleModalTitle.textContent = `Купить "${name}"`;
    buyMultipleGiftName.textContent = `Укажите количество для "${name}"`;
    buyMultipleQuantityInput.value = "1";
    buyMultipleModal.classList.add('active');
    buyMultipleQuantityInput.focus();
}
function handleConfirmBuyMultiple() { /* Modified to pass lottiePath to buyGift */
    if (!currentGiftToBuyMultiple) return;
    const quantity = parseInt(buyMultipleQuantityInput.value, 10);
    if (isNaN(quantity) || quantity < 1) { tg.showAlert("Пожалуйста, введите корректное количество."); return; }
    buyGift(currentGiftToBuyMultiple.id, currentGiftToBuyMultiple.name, currentGiftToBuyMultiple.originalImage, currentGiftToBuyMultiple.lottiePath, quantity);
    closeModal(buyMultipleModal);
    currentGiftToBuyMultiple = null;
}
function buyGift(id, name, originalImage, lottiePath, quantity = 1) { // Accept lottiePath
    for (let i = 0; i < quantity; i++) {
        ownedGifts.unshift({
            id, instanceId: generateUniqueId(), name, originalImage, lottiePath, // Store Lottie path
            isCollectible: false, collectibleData: null, acquiredDate: new Date().toISOString()
        });
    }
    saveState(); renderProfileGifts(); populateFilterOptions();
    tg.HapticFeedback.notificationOccurred('success');
    const message = quantity > 1 ? `"${name}" (${quantity} шт.) добавлены!` : `"${name}" добавлен!`;
    tg.showAlert(message); showPage('profile-page');
}

function openGiftDetailByInstanceId(instanceId) { /* Same as previous version with Lottie in modals */ 
    const gift = ownedGifts.find(g => g.instanceId === instanceId);
    if (!gift) return;
    if (gift.isCollectible && gift.collectibleData) {
        const cd = gift.collectibleData;
        collectibleDetailModal.dataset.instanceId = gift.instanceId;
        modalCollectibleHeaderTitle.textContent = gift.name;
        modalCollectibleMainName.textContent = cd.model?.name || gift.name;
        modalCollectibleNumberSubtext.textContent = `Коллекционный #${cd.number}`;
        modalCollectibleBg.style.background = `radial-gradient(circle, ${cd.backdropColors?.centerColor || '#555'}, ${cd.backdropColors?.edgeColor || '#333'})`;
        modalCollectiblePattern.style.backgroundImage = cd.patternImage ? `url('${cd.patternImage}')` : 'none';
        if (cd.lottieModelPath) { playLottieAnimation(modalLottieCollectibleModel, cd.lottieModelPath, true); modalCollectibleModelImgStatic.style.display = 'none'; } 
        else { destroyLottieAnimation(modalLottieCollectibleModel); modalCollectibleModelImgStatic.src = cd.modelImage || gift.originalImage; modalCollectibleModelImgStatic.style.display = 'block'; modalCollectibleModelImgStatic.onerror = function() { this.src = `https://i.pravatar.cc/200?u=err${generateUniqueId()}`; }; }
        const ownerName = profileName.textContent; const ownerAvatar = profileAvatar.src;
        modalCollectibleInfoTable.innerHTML = `
            <div class="info-row"><span class="info-label">Владелец</span><span class="info-value"><img src="${ownerAvatar}" alt="" class="owner-avatar">${ownerName}</span></div>
            <div class="info-row"><span class="info-label">Модель</span><span class="info-value">${cd.model?.name || 'N/A'} <span class="rarity-chip">${(cd.model?.rarityPermille || 0) / 10}%</span></span></div>
            <div class="info-row"><span class="info-label">Фон</span><span class="info-value">${cd.backdrop?.name || 'N/A'} <span class="rarity-chip">${(cd.backdrop?.rarityPermille || 0) / 10}%</span></span></div>
            <div class="info-row"><span class="info-label">Символ</span><span class="info-value">${cd.pattern?.name || 'N/A'} <span class="rarity-chip">${(cd.pattern?.rarityPermille || 0) / 10}%</span></span></div>
            <div class="info-row"><span class="info-label">Количество</span><span class="info-value">#${cd.number} (Уникальный)</span></div>`;
        collectibleActionWear.querySelector('.text').textContent = (wornGiftInstanceId === gift.instanceId) ? 'Снять' : 'Надеть';
        collectibleDetailModal.classList.add('active');
    } else {
        modalGiftName.textContent = "Сохраненный подарок";
        if (gift.lottiePath) { playLottieAnimation(modalLottieGiftOriginal, gift.lottiePath, true); modalGiftImageStatic.style.display = 'none'; } 
        else { destroyLottieAnimation(modalLottieGiftOriginal); modalGiftImageStatic.src = gift.originalImage; modalGiftImageStatic.style.display = 'block'; modalGiftImageStatic.onerror = function() { this.src = `https://i.pravatar.cc/100?u=err${generateUniqueId()}`; };}
        modalGiftDescription1.textContent = `Добавьте «${gift.name}» в свой профиль или улучшите его.`;
        modalGiftDescription2.textContent = "Только вы можете видеть имя отправителя.";
        modalGiftInfo.innerHTML = `
            <div class="info-row"><span class="info-label">Дата</span><span class="info-value">${new Date(gift.acquiredDate).toLocaleDateString('ru-RU', {day:'numeric', month:'short', year:'numeric', hour:'2-digit', minute:'2-digit'})}</span></div>
            <div class="info-row"><span class="info-label">Стоимость</span><span class="info-value"><span class="star-icon">⭐</span> Бесплатно</span></div>
            <div class="info-row"><span class="info-label">Доступность</span><span class="info-value">Ограничено</span></div>
            <div class="info-row" id="uniqueness-row-${gift.instanceId}"><span class="info-label">Уникальность</span><div class="info-value-with-action"><span id="modal-uniqueness-value-${gift.instanceId}">Стандартный</span><button id="modal-action-upgrade-gift-${gift.instanceId}" class="button-link-styled" data-instance-id="${gift.instanceId}">Улучшить</button></div></div>`;
        giftDetailModal.classList.add('active');
        const inlineUpgradeBtn = document.getElementById(`modal-action-upgrade-gift-${gift.instanceId}`);
        if (inlineUpgradeBtn) inlineUpgradeBtn.addEventListener('click', (e) => handleSingleGiftUpgradeFromModal(e.target.dataset.instanceId));
    }
}
async function upgradeSingleGiftLogic(giftToUpgrade) { /* Same as previous, ensures lottieModelPath is set */ 
    if (giftToUpgrade.isCollectible) return { instanceId: giftToUpgrade.instanceId, name: giftToUpgrade.name, status: 'skipped' };
    const giftNameEncoded = encodeURIComponent(giftToUpgrade.name);
    try {
        const [modelsRes, backdropsRes, patternsRes] = await Promise.all([
            fetch(`${CDN_BASE_URL}models/${giftNameEncoded}/models.json`),
            fetch(`${CDN_BASE_URL}backdrops/${giftNameEncoded}/backdrops.json`),
            fetch(`${CDN_BASE_URL}patterns/${giftNameEncoded}/patterns.json`)
        ]);
        if (!modelsRes.ok) throw new Error(`Модели (${giftToUpgrade.name}) не найдены.`);
        if (!backdropsRes.ok) throw new Error(`Фоны (${giftToUpgrade.name}) не найдены.`);
        if (!patternsRes.ok) throw new Error(`Символы (${giftToUpgrade.name}) не найдены.`);
        const [modelsData, backdropsData, patternsData] = await Promise.all([modelsRes.json(), backdropsRes.json(), patternsRes.json()]);
        if (!modelsData?.length || !backdropsData?.length || !patternsData?.length) throw new Error(`Нет данных для улучшения "${giftToUpgrade.name}".`);
        const selectedModel = selectWeightedRandom(modelsData);
        const selectedBackdrop = selectWeightedRandom(backdropsData);
        const selectedPattern = selectWeightedRandom(patternsData);
        const randomNumber = Math.floor(Math.random() * 200000) + 1;
        const giftIndexInOwned = ownedGifts.findIndex(g => g.instanceId === giftToUpgrade.instanceId);
        if (giftIndexInOwned !== -1) {
            const newCollectibleData = {
                model: selectedModel, backdrop: selectedBackdrop, pattern: selectedPattern, number: randomNumber,
                modelImage: `${CDN_BASE_URL}models/${giftNameEncoded}/png/${encodeURIComponent(selectedModel.name)}.png`,
                lottieModelPath: `${CDN_BASE_URL}models/${giftNameEncoded}/lottie/${encodeURIComponent(selectedModel.name)}.json`,
                patternImage: `${CDN_BASE_URL}patterns/${giftNameEncoded}/png/${encodeURIComponent(selectedPattern.name)}.png`,
                backdropColors: selectedBackdrop.hex,
            };
            ownedGifts[giftIndexInOwned] = { ...ownedGifts[giftIndexInOwned], isCollectible: true, collectibleData: newCollectibleData, lottiePath: null };
            return { instanceId: giftToUpgrade.instanceId, name: giftToUpgrade.name, status: 'success', collectibleData: newCollectibleData };
        } else throw new Error(`Подарок "${giftToUpgrade.name}" не найден.`);
    } catch (error) {
        console.error(`Ошибка улучшения для "${giftToUpgrade.name}" (ID: ${giftToUpgrade.instanceId}):`, error);
        return { instanceId: giftToUpgrade.instanceId, name: giftToUpgrade.name, status: 'failed', error: error.message };
    }
}
async function handleSingleGiftUpgradeFromModal(instanceId) { /* Same as before */ 
    const gift = ownedGifts.find(g => g.instanceId === instanceId);
    if (!gift || gift.isCollectible) return;
    const upgradeButton = document.getElementById(`modal-action-upgrade-gift-${instanceId}`);
    const uniquenessValueEl = document.getElementById(`modal-uniqueness-value-${instanceId}`);
    if (upgradeButton) { upgradeButton.textContent = 'Улучшение...'; upgradeButton.disabled = true; }
    if (uniquenessValueEl) uniquenessValueEl.textContent = 'Обработка...';
    const result = await upgradeSingleGiftLogic(gift);
    if (result.status === 'success' && result.collectibleData) {
        if (uniquenessValueEl) uniquenessValueEl.textContent = `Коллекционный #${result.collectibleData.number}`;
        saveState(); renderProfileGifts(); populateFilterOptions();
        tg.HapticFeedback.notificationOccurred('success');
        setTimeout(() => { closeModal(giftDetailModal); openGiftDetailByInstanceId(gift.instanceId); }, 1200);
    } else {
        tg.showAlert(`Не удалось улучшить "${gift.name}". ${result.error || ''}`);
        if (uniquenessValueEl) uniquenessValueEl.textContent = 'Ошибка';
        if (upgradeButton) { upgradeButton.textContent = 'Улучшить'; upgradeButton.disabled = false; }
    }
}
async function handleUpgradeAllGifts() { /* Same as before, relies on createGiftCardDOM for render update */ 
    const giftsToUpgrade = ownedGifts.filter(g => !g.isCollectible);
    if (giftsToUpgrade.length === 0) { tg.showAlert("Нет подарков для улучшения."); return; }
    const originalButtonText = upgradeAllGiftsButton.textContent;
    upgradeAllGiftsButton.disabled = true;
    let successCount = 0, failureCount = 0;
    for (let i = 0; i < giftsToUpgrade.length; i++) {
        const gift = giftsToUpgrade[i];
        upgradeAllGiftsButton.textContent = `Улучшение (${i + 1}/${giftsToUpgrade.length})...`;
        const cardElement = giftsGrid.querySelector(`.gift-card[data-instance-id="${gift.instanceId}"]`);
        if (cardElement) cardElement.classList.add('is-updating');
        const result = await upgradeSingleGiftLogic(gift);
        if (cardElement) cardElement.classList.remove('is-updating');
        if (result.status === 'success') {
            successCount++;
            if (cardElement && result.collectibleData) { // Card still exists and upgrade was successful
                const updatedGiftData = ownedGifts.find(g => g.instanceId === gift.instanceId);
                if (updatedGiftData) {
                     // The card's content will be complex, direct innerHTML might be easier if Lottie instances are managed by observer
                    const newCard = createGiftCardDOM(updatedGiftData); // Create new DOM fragment
                    cardElement.innerHTML = newCard.innerHTML; // Replace content
                    // Crucially, re-observe if necessary or ensure data attributes are correct
                    cardElement.dataset.lottiePath = updatedGiftData.isCollectible && updatedGiftData.collectibleData ? updatedGiftData.collectibleData.lottieModelPath : updatedGiftData.lottiePath;
                    // Old Lottie instance on cardElement (if any via observer) might be orphaned. Observer should handle this.
                    setupLongPress(cardElement, updatedGiftData);
                }
            }
        } else if (result.status === 'failed') failureCount++;
        if (giftsToUpgrade.length > 1 && i < giftsToUpgrade.length - 1) await new Promise(resolve => setTimeout(resolve, 200));
    }
    saveState(); populateFilterOptions();
    let summaryMessage = `Улучшение завершено.\nУспешно: ${successCount}`;
    if (failureCount > 0) summaryMessage += `\nНе удалось: ${failureCount}`;
    tg.showAlert(summaryMessage);
    tg.HapticFeedback.notificationOccurred(successCount > 0 ? 'success' : (failureCount > 0 ? 'error' : 'warning'));
    const stillHasNonCollectible = ownedGifts.some(g => !g.isCollectible);
    upgradeAllGiftsButton.style.display = stillHasNonCollectible ? 'inline-block' : 'none';
    if (stillHasNonCollectible) { upgradeAllGiftsButton.textContent = originalButtonText; upgradeAllGiftsButton.disabled = false; }
}
function selectWeightedRandom(items) { /* Same as before */ 
    if (!items || items.length === 0) return null;
    let totalWeight = items.reduce((sum, item) => sum + (item.rarityPermille || 1), 0);
    if (totalWeight === 0) return items[Math.floor(Math.random() * items.length)];
    let randomNum = Math.random() * totalWeight;
    for (let item of items) {
        if (randomNum < (item.rarityPermille || 1)) return item;
        randomNum -= (item.rarityPermille || 1);
    }
    return items[items.length - 1];
}
function closeModal(modalElement) { /* Modified to stop Lottie */ 
    if (modalElement.id === 'gift-detail-modal') destroyLottieAnimation(modalLottieGiftOriginal);
    if (modalElement.id === 'collectible-detail-modal') destroyLottieAnimation(modalLottieCollectibleModel);
    modalElement.classList.remove('active');
}
let currentLongPressGift = null; let longPressTimer; /* Long press logic same as before */
function setupLongPress(element, gift) { 
    element.addEventListener('touchstart', (e) => {
        clearTimeout(longPressTimer);
        longPressTimer = setTimeout(() => openLongPressMenu(gift, e.touches[0]), 500);
    }, { passive: false });
    element.addEventListener('touchend', () => clearTimeout(longPressTimer));
    element.addEventListener('touchmove', () => clearTimeout(longPressTimer));
    element.addEventListener('contextmenu', (e) => { e.preventDefault(); clearTimeout(longPressTimer); openLongPressMenu(gift, e); });
}
function openLongPressMenu(gift, eventCoords) {
    currentLongPressGift = gift;
    if (!gift.isCollectible) { menuPinAction.textContent = 'Закрепить (только коллекционные)'; menuPinAction.classList.add('disabled'); }
    else { const isPinned = pinnedGifts.includes(gift.instanceId); menuPinAction.textContent = isPinned ? 'Открепить' : 'Закрепить'; menuPinAction.classList.remove('disabled'); }
    longPressMenu.style.top = `${Math.min(eventCoords.clientY, window.innerHeight - longPressMenu.offsetHeight - 10)}px`;
    longPressMenu.style.left = `${Math.min(eventCoords.clientX, window.innerWidth - longPressMenu.offsetWidth - 10)}px`;
    longPressMenu.classList.remove('hidden');
    document.addEventListener('click', closeLongPressMenuOnClickOutside, { once: true, capture: true });
}
function closeLongPressMenuOnClickOutside(event) {
    if (!longPressMenu.contains(event.target) && event.target !== longPressMenu) { longPressMenu.classList.add('hidden'); currentLongPressGift = null; }
}
function handlePinAction() {
    if (!currentLongPressGift || menuPinAction.classList.contains('disabled')) {
        longPressMenu.classList.add('hidden');
        if (currentLongPressGift && !currentLongPressGift.isCollectible) tg.showAlert("Только коллекционные подарки можно закреплять.");
        currentLongPressGift = null; return;
    }
    const giftInstanceId = currentLongPressGift.instanceId; const isPinned = pinnedGifts.includes(giftInstanceId);
    if (isPinned) pinnedGifts = pinnedGifts.filter(id => id !== giftInstanceId);
    else { if (pinnedGifts.length >= MAX_PINS) { showTooManyPinsModal(); longPressMenu.classList.add('hidden'); return; } pinnedGifts.push(giftInstanceId); }
    saveState(); renderProfileGifts(); longPressMenu.classList.add('hidden');
    tg.HapticFeedback.impactOccurred(isPinned ? 'light' : 'medium'); currentLongPressGift = null;
}
function showTooManyPinsModal() {
    unpinSelectionGrid.innerHTML = '';
    pinnedGifts.forEach(pinnedInstanceId => {
        const giftToUnpin = ownedGifts.find(g => g.instanceId === pinnedInstanceId);
        if (giftToUnpin) {
            const card = createGiftCardDOM(giftToUnpin); // This will setup for Lottie observation too
            card.addEventListener('click', () => {
                pinnedGifts = pinnedGifts.filter(id => id !== pinnedInstanceId);
                if (currentLongPressGift && currentLongPressGift.isCollectible && !pinnedGifts.includes(currentLongPressGift.instanceId)) {
                    pinnedGifts.push(currentLongPressGift.instanceId);
                }
                saveState(); renderProfileGifts(); closeModal(tooManyPinsModal);
                tg.HapticFeedback.impactOccurred('medium'); currentLongPressGift = null;
            });
            unpinSelectionGrid.appendChild(card);
            observeLottieElement(card); // Observe the card in the modal grid
        }
    });
    tooManyPinsModal.classList.add('active');
}
function handleWearAction() { /* Same as before, relies on applyWornGiftStyles for Lottie */
    const currentModalInstanceId = collectibleDetailModal.dataset.instanceId; if (!currentModalInstanceId) return;
    if (wornGiftInstanceId === currentModalInstanceId) { wornGiftInstanceId = null; collectibleActionWear.querySelector('.text').textContent = 'Надеть'; }
    else { wornGiftInstanceId = currentModalInstanceId; collectibleActionWear.querySelector('.text').textContent = 'Снять'; }
    applyWornGiftStyles(wornGiftInstanceId); saveState(); tg.HapticFeedback.impactOccurred('light');
}
let filterPopupLongPressTimer; /* Filter logic same as before */
function setupFilterPopupTrigger() {
    filterLongPressTarget.addEventListener('touchstart', (e) => { filterPopupLongPressTimer = setTimeout(openFilterPopup, 700); }, { passive: true });
    filterLongPressTarget.addEventListener('touchend', () => clearTimeout(filterPopupLongPressTimer));
    filterLongPressTarget.addEventListener('touchmove', () => clearTimeout(filterPopupLongPressTimer));
    filterLongPressTarget.addEventListener('contextmenu', (e) => { e.preventDefault(); openFilterPopup(); });
}
function openFilterPopup() { populateFilterOptions(); filterPopup.classList.add('active'); }
function populateFilterOptions() {
    const uniqueCollections = [...new Map(ownedGifts.map(item => [item.id, {id: item.id, name: item.name, image: item.originalImage}])).values()];
    renderFilterOptions(filterOptionsCollections, uniqueCollections, 'collection', (item) => `<img src="${item.image}" alt="${item.name}">`);
    if (activeFilters.collection) {
        const giftsInCollection = ownedGifts.filter(g => g.id === activeFilters.collection && g.isCollectible && g.collectibleData?.model);
        const uniqueModels = [...new Map(giftsInCollection.map(item => [item.collectibleData.model.name, {name: item.collectibleData.model.name, image: item.collectibleData.modelImage}])).values()];
        renderFilterOptions(filterOptionsModels, uniqueModels, 'model', (item) => `<img src="${item.image}" alt="${item.name}">`);
        filterModelsSection.classList.remove('hidden');
    } else { filterModelsSection.classList.add('hidden'); filterOptionsModels.innerHTML = ''; }
    const collectibleGifts = ownedGifts.filter(g => g.isCollectible && g.collectibleData?.backdrop);
    const uniqueBackdrops = [...new Map(collectibleGifts.map(item => [item.collectibleData.backdrop.name, {name: item.collectibleData.backdrop.name, colors: item.collectibleData.backdropColors}])).values()];
    renderFilterOptions(filterOptionsBackdrops, uniqueBackdrops, 'backdrop', (item) => `<div class="gradient-square" style="background: radial-gradient(circle, ${item.colors.centerColor}, ${item.colors.edgeColor});"></div>`);
    const uniquePatterns = [...new Map(collectibleGifts.filter(g => g.collectibleData.pattern).map(item => [item.collectibleData.pattern.name, {name: item.collectibleData.pattern.name, image: item.collectibleData.patternImage}])).values()];
    renderFilterOptions(filterOptionsPatterns, uniquePatterns, 'pattern', (item) => `<img src="${item.image}" alt="${item.name}">`);
}
function renderFilterOptions(container, items, filterType, displayFn) {
    container.innerHTML = '';
    items.forEach(item => {
        const optionEl = document.createElement('div'); optionEl.className = 'filter-option';
        optionEl.innerHTML = displayFn(item);
        const valueToCompare = filterType === 'collection' ? item.id : item.name;
        if (activeFilters[filterType] === valueToCompare) optionEl.classList.add('selected');
        optionEl.addEventListener('click', () => {
            if (activeFilters[filterType] === valueToCompare) {
                activeFilters[filterType] = null;
                if (filterType === 'collection') activeFilters.model = null;
            } else {
                activeFilters[filterType] = valueToCompare;
                if (filterType === 'collection') activeFilters.model = null;
            }
            populateFilterOptions();
        });
        container.appendChild(optionEl);
    });
}
function handleApplyFilters() { renderProfileGifts(); saveState(); closeModal(filterPopup); }
function handleClearFilters() {
    activeFilters = { collection: null, model: null, backdrop: null, pattern: null };
    populateFilterOptions(); renderProfileGifts(); saveState();
}
function handleClearAllData() {
    tg.showConfirm("Вы уверены, что хотите удалить все свои подарки и данные? Это действие необратимо.", (confirmed) => {
        if (confirmed) {
            ownedGifts = []; pinnedGifts = []; wornGiftInstanceId = null;
            activeFilters = { collection: null, model: null, backdrop: null, pattern: null };
            // Clear Lottie from grids and pinned area
            Array.from(giftsGrid.children).forEach(child => unobserveLottieElement(child));
            Array.from(buyGiftsGrid.children).forEach(child => unobserveLottieElement(child));
            Array.from(profileTopPinnedGifts.children).forEach(childLottieContainer => destroyLottieAnimation(childLottieContainer));
            
            saveState(); applyWornGiftStyles(null); renderProfileGifts(); populateFilterOptions();
            tg.HapticFeedback.notificationOccurred('success'); tg.showAlert("Все данные удалены.");
            closeModal(filterPopup);
        }
    });
}

function setupEventListeners() { /* Same as before, ensures IntersectionObserver related calls are in place */
    goToBuyGiftsButton.addEventListener('click', () => showPage('buy-gifts-page'));
    if (upgradeAllGiftsButton) upgradeAllGiftsButton.addEventListener('click', handleUpgradeAllGifts);
    backToProfileBuyButton.addEventListener('click', () => showPage('profile-page'));
    closeGiftDetailModalButton.addEventListener('click', () => closeModal(giftDetailModal));
    backFromCollectibleModal.addEventListener('click', () => closeModal(collectibleDetailModal));
    collectibleActionWear.addEventListener('click', handleWearAction);
    closeCollectibleDetailModalButton.addEventListener('click', () => closeModal(collectibleDetailModal));
    menuPinAction.addEventListener('click', handlePinAction);
    cancelUnpinModal.addEventListener('click', () => { closeModal(tooManyPinsModal); currentLongPressGift = null; });
    confirmBuyMultipleButton.addEventListener('click', handleConfirmBuyMultiple);
    cancelBuyMultipleButton.addEventListener('click', () => closeModal(buyMultipleModal));
    [giftDetailModal, collectibleDetailModal, tooManyPinsModal, buyMultipleModal, filterPopup].forEach(modal => {
        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(modal); });
    });
    // Scroll listeners are handled by IntersectionObserver for Lottie grid items
    // giftsGrid.addEventListener('scroll', () => { if(!longPressMenu.classList.contains('hidden')) { longPressMenu.classList.add('hidden'); currentLongPressGift = null; } });
    setupFilterPopupTrigger();
    applyFiltersButton.addEventListener('click', handleApplyFilters);
    clearFiltersButton.addEventListener('click', handleClearFilters);
    clearAllDataButton.addEventListener('click', handleClearAllData);
}

if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initData !== undefined) {
    initApp();
} else {
    console.warn("Telegram WebApp не найден. Используются мок-данные и тема по умолчанию.");
    document.addEventListener('DOMContentLoaded', () => {
        tg.initDataUnsafe = { user: mockUser };
        tg.themeParams = {};
        tg.showAlert = (message) => alert(message);
        tg.showConfirm = (message, callback) => callback(confirm(message));
        tg.HapticFeedback = {
            impactOccurred: (style) => console.log(`Haptic: ${style}`),
            notificationOccurred: (type) => console.log(`Haptic Notification: ${type}`),
        };
        tg.ready = () => {}; tg.expand = () => {}; tg.onEvent = () => {};
        initApp();
    });
}
</script>
</body>
</html>
